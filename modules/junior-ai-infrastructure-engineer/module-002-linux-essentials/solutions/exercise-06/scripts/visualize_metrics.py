#!/usr/bin/env python3
"""
visualize_metrics.py - Training Metrics Visualization

Description:
    Visualizes training metrics from CSV files generated by extract_metrics.sh.
    Creates plots for loss and accuracy over epochs.

Usage:
    python3 visualize_metrics.py [metrics_csv] [output_png]

Requirements:
    - matplotlib
    - numpy (optional, for enhanced statistics)
"""

import sys
import csv
import argparse
from pathlib import Path

try:
    import matplotlib
    matplotlib.use('Agg')  # Non-interactive backend
    import matplotlib.pyplot as plt
except ImportError:
    print("Error: matplotlib not found. Install with: pip install matplotlib")
    sys.exit(1)

# Colors for plots
COLORS = {
    'train': '#2E86AB',
    'val': '#A23B72',
    'grid': '#E0E0E0'
}


def parse_arguments():
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description='Visualize training metrics from CSV file'
    )
    parser.add_argument(
        'metrics_csv',
        nargs='?',
        default='training_metrics.csv',
        help='Path to metrics CSV file (default: training_metrics.csv)'
    )
    parser.add_argument(
        'output_png',
        nargs='?',
        default='training_metrics.png',
        help='Output PNG file path (default: training_metrics.png)'
    )
    parser.add_argument(
        '--dpi',
        type=int,
        default=150,
        help='Output image DPI (default: 150)'
    )
    parser.add_argument(
        '--style',
        choices=['default', 'seaborn', 'ggplot', 'dark'],
        default='default',
        help='Plot style (default: default)'
    )
    parser.add_argument(
        '--no-show-improvement',
        action='store_true',
        help='Don\'t show improvement percentages'
    )

    return parser.parse_args()


def read_metrics(csv_path):
    """Read metrics from CSV file."""
    if not Path(csv_path).exists():
        print(f"Error: File not found: {csv_path}")
        sys.exit(1)

    epochs = []
    loss = []
    accuracy = []
    val_loss = []
    val_accuracy = []

    try:
        with open(csv_path, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                epochs.append(int(row['epoch']))
                loss.append(float(row['loss']))
                accuracy.append(float(row['accuracy']))
                val_loss.append(float(row['val_loss']))
                val_accuracy.append(float(row['val_accuracy']))
    except Exception as e:
        print(f"Error reading CSV file: {e}")
        sys.exit(1)

    if not epochs:
        print("Error: No data found in CSV file")
        sys.exit(1)

    return {
        'epochs': epochs,
        'loss': loss,
        'accuracy': accuracy,
        'val_loss': val_loss,
        'val_accuracy': val_accuracy
    }


def calculate_improvement(data):
    """Calculate improvement metrics."""
    loss_improvement = ((data['loss'][0] - data['loss'][-1]) /
                       data['loss'][0] * 100)
    acc_improvement = ((data['accuracy'][-1] - data['accuracy'][0]) /
                      data['accuracy'][0] * 100)

    return {
        'loss_improvement': loss_improvement,
        'acc_improvement': acc_improvement
    }


def create_plot(data, output_path, args):
    """Create training metrics visualization."""
    # Set style
    if args.style != 'default':
        try:
            plt.style.use(args.style)
        except:
            print(f"Warning: Style '{args.style}' not available, using default")

    # Create figure with two subplots
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

    # Plot 1: Loss
    ax1.plot(data['epochs'], data['loss'],
             label='Training Loss',
             marker='o',
             color=COLORS['train'],
             linewidth=2,
             markersize=6)
    ax1.plot(data['epochs'], data['val_loss'],
             label='Validation Loss',
             marker='s',
             color=COLORS['val'],
             linewidth=2,
             markersize=6)

    ax1.set_xlabel('Epoch', fontsize=12, fontweight='bold')
    ax1.set_ylabel('Loss', fontsize=12, fontweight='bold')
    ax1.set_title('Training and Validation Loss', fontsize=14, fontweight='bold')
    ax1.legend(loc='upper right', framealpha=0.9)
    ax1.grid(True, alpha=0.3, color=COLORS['grid'])

    # Add improvement annotation
    if not args.no_show_improvement:
        improvement = calculate_improvement(data)
        ax1.text(0.02, 0.98,
                f'Improvement: {improvement["loss_improvement"]:.1f}%',
                transform=ax1.transAxes,
                verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5),
                fontsize=10)

    # Plot 2: Accuracy
    ax2.plot(data['epochs'], data['accuracy'],
             label='Training Accuracy',
             marker='o',
             color=COLORS['train'],
             linewidth=2,
             markersize=6)
    ax2.plot(data['epochs'], data['val_accuracy'],
             label='Validation Accuracy',
             marker='s',
             color=COLORS['val'],
             linewidth=2,
             markersize=6)

    ax2.set_xlabel('Epoch', fontsize=12, fontweight='bold')
    ax2.set_ylabel('Accuracy', fontsize=12, fontweight='bold')
    ax2.set_title('Training and Validation Accuracy', fontsize=14, fontweight='bold')
    ax2.legend(loc='lower right', framealpha=0.9)
    ax2.grid(True, alpha=0.3, color=COLORS['grid'])

    # Add improvement annotation
    if not args.no_show_improvement:
        improvement = calculate_improvement(data)
        ax2.text(0.02, 0.02,
                f'Improvement: {improvement["acc_improvement"]:.1f}%',
                transform=ax2.transAxes,
                verticalalignment='bottom',
                bbox=dict(boxstyle='round', facecolor='lightgreen', alpha=0.5),
                fontsize=10)

    # Overall title
    fig.suptitle('ML Training Metrics Visualization',
                fontsize=16,
                fontweight='bold',
                y=1.02)

    # Adjust layout
    plt.tight_layout()

    # Save figure
    try:
        plt.savefig(output_path, dpi=args.dpi, bbox_inches='tight')
        print(f"✓ Plot saved to: {output_path}")
    except Exception as e:
        print(f"Error saving plot: {e}")
        sys.exit(1)

    return fig


def print_statistics(data):
    """Print training statistics."""
    improvement = calculate_improvement(data)

    print("\n" + "="*50)
    print(" Training Metrics Statistics")
    print("="*50)

    print(f"\nEpochs: {len(data['epochs'])}")

    print("\nLoss:")
    print(f"  First:       {data['loss'][0]:.4f}")
    print(f"  Last:        {data['loss'][-1]:.4f}")
    print(f"  Best:        {min(data['loss']):.4f}")
    print(f"  Average:     {sum(data['loss'])/len(data['loss']):.4f}")
    print(f"  Improvement: {improvement['loss_improvement']:.1f}%")

    print("\nAccuracy:")
    print(f"  First:       {data['accuracy'][0]:.4f}")
    print(f"  Last:        {data['accuracy'][-1]:.4f}")
    print(f"  Best:        {max(data['accuracy']):.4f}")
    print(f"  Average:     {sum(data['accuracy'])/len(data['accuracy']):.4f}")
    print(f"  Improvement: {improvement['acc_improvement']:.1f}%")

    print("\nValidation Metrics:")
    print(f"  Best Val Loss:     {min(data['val_loss']):.4f}")
    print(f"  Best Val Accuracy: {max(data['val_accuracy']):.4f}")

    # Check for overfitting
    final_gap = data['val_loss'][-1] - data['loss'][-1]
    if final_gap > 0.1:
        print("\n⚠ Warning: Possible overfitting detected")
        print(f"  Final gap: {final_gap:.4f}")
    else:
        print("\n✓ No significant overfitting detected")

    print("\n" + "="*50 + "\n")


def main():
    """Main function."""
    args = parse_arguments()

    print(f"Reading metrics from: {args.metrics_csv}")
    data = read_metrics(args.metrics_csv)

    print(f"Generating visualization...")
    create_plot(data, args.output_png, args)

    print_statistics(data)

    print("Visualization complete!")


if __name__ == '__main__':
    main()
